N/B:
CREATE OR REPLACE FUNCTION fn_name(int, int) RETURNS int AS  || DO  -- For quick testing purpose.


__Return Type__
int
void
trigger

CREATE OR REPLACE FUNCTION fn_sum(int, int) RETURNS int AS
BEGIN
END;
LANGUAGE plpgsql;

__FORMAT OUTPUT COMPOSITE RETURN__
CREATE OR REPLACE FUNCTION fn_latest_hire() RETURNS employees
    AS
$$
    SELECT * FROM employees order by hire_date desc;
$$LANGUAGE SQL;
SELECT (fn_latest_hire()).*;

__SETOF__
CREATE  OR REPLACE FUNCTION fn_returns_hire_per_year(years varchar) RETURNS SETOF employees
AS $$

    SELECT * FROM employees
    WHERE extract('YEAR' FROM hire_date)='1992';
    $$ LANGUAGE SQL;

SELECT fn_returns_hire_per_year('1992');

__DEFAULT PARAM__
CREATE  OR REPLACE FUNCTION fn_sum(x int DEFALT 10,y int DEFAULT 11)
SELECT fn_sum() --value 11
__STRUCTURE PLPGSQL__

CREATE OR REPLACE FUNCTION fn_name(par1 Type,par2 Type) RETURNS type
AS
  $$
   DECLARE
   	var1 Type;
   	var ALIAS FOR $1 --aka par1
   BEGIN
   END;
  $$LANGUAGE PLPGSQL;
__ALIAS FOR(KEY WORD)__  
var ALIAS FOR $1 --aka par1
__RAISE NOTICE(print)__
RAISE NOTICE 'The value of output is %' value; --fstring like;
__Data Type Inherit__
varname tabel.column%TYPE; --Inherits the type of column.
__Query into variable__
SELECT column FROM table INTO declaredVar;
RAISE NOTICE 'The feedback is %' declaredVar;
__IN OUT Replace RETURN__

CREATE OR REPLACE FUNCTION fn_name (IN par1 Type, IN par2 Type, OUT par3 Type)
AS
$$
  par3 = par1 + par2;
$$ LANGUAGE PLPGSQL;


__Blocks__
<<Block>>
DECLARE
BEGIN
	--Sub Block
	DECLARE
	BEGIN
	END;
END Block;
__Returning Query Results__

CREATE OR REPLACE FUNCTION fn_name() RETRUNS SETOF tb_name 
AS
$$
   BEGIN
      RETURN QUERY SELECT * FROM tb_name;
   END;
$$ LANGUAGE PLPGSQL

__CONDITIONAL STMNT__

IF cond..THEN
ELSE cond... THEN
END IF;

__LOOP STATEMENT__
DO
$$
    DECLARE
         i int = 0;
    BEGIN
        LOOP

        RAISE NOTICE 'i is: %', i;
        i=i+1;
        EXIT WHEN i = 5;
        END LOOP;
    end;
$$ LANGUAGE plpgsql;
DO
$$
    BEGIN
        FOR i in REVERSE 10..1
        LOOP
        RAISE NOTICE 'i is: %', i;
        END LOOP;
    end;
$$ LANGUAGE plpgsql;
DO
$$
    BEGIN
        FOR i in [REVERSE] 1..10
        LOOP
        RAISE NOTICE 'i is: %', i;
        END LOOP;
    end;
$$ LANGUAGE plpgsql;
__FOR WITH STEP__
DO
$$
    BEGIN
        FOR i in 1..10 BY 2
        LOOP
        RAISE NOTICE 'i is: %', i;
        END LOOP;
    end;
$$ LANGUAGE plpgsql;
__FOR LOOP WITH RECORD__
DO
$$
    DECLARE
        rec record;
    BEGIN
        FOR rec IN
            SELECT customer_id, order_id FROM orders LIMIT 10
        LOOP
            RAISE NOTICE 'The Customer % Ordered %', rec.customer_id, rec.order_id;
        end loop;
    END;
$$ LANGUAGE PLPGSQL;

__CONTINUE CLAUSE__
DO
$$
    BEGIN
        FOR i in  1..20
        LOOP
        CONTINUE WHEN
             mod(i,2) = 0;
         RAISE NOTICE 'i is: %', i;

        END LOOP;
    end;
$$ LANGUAGE plpgsql;
__FOR EACH__
DO
$$
    DECLARE
        arr1 int[] = array [1,2,3,4];
        var int;
    BEGIN
        foreach var in array arr1
        LOOP
            RAISE NOTICE 'The current element is: %', var;
        end loop;
    END;
$$ language plpgsql;

__RETURN TABLE__
CREATE OR REPLACE FUNCTION fn_pattern(pattern varchar) RETURNS TABLE(contactName varchar, contactTittle varchar)
AS
    $$
        BEGIN
            RETURN QUERY
            SELECT
                contact_name,
                contact_title
            FROM customers
            WHERE customer_id LIKE pattern;

        end;
    $$ LANGUAGE plpgsql;

SELECT fn_pattern('ALFKI');

RETURN NEXT r --type record


__EXCEPTION HANDLING__
CREATE OR REPLACE FUNCTION fn_find_order() RETURNS SETOF orders
AS
    $$
        DECLARE
        rec record;
        uid smallint = 1;
        BEGIN
            SELECT
                *
            INTO STRICT rec
            FROM orders
            WHERE order_id = uid;
            EXCEPTION
            WHEN NO_DATA_FOUND||TOO_MANY_ROWS THEN
              RAISE EXCEPTION 'No data found with the said condition';
        END;


    $$LANGUAGE plpgsql;

SELECT fn_find_order();


__ERROR CODE__
WHEN SQLSTATE 'P0002' = NO_DATA_FOUND

__TRIGGER MASTER__
CREATE OR REPLACE FUNCTION fn_info() RETURNS TRIGGER AS
$$
    BEGIN
        RAISE NOTICE 'TG_RELNAME %' ,TG_RELNAME;
        RAISE NOTICE 'G_TABLE_SCHEMA %',TG_TABLE_SCHEMA;
        RAISE NOTICE 'TG_TABLE_NAME %', TG_TABLE_NAME;
        RAISE NOTICE 'TG_WHEN %' ,TG_WHEN;
        RAISE NOTICE 'TG_LEVEL %',TG_LEVEL;
        RAISE NOTICE 'TG_OP %', TG_OP;
        RAISE NOTICE 'TG_NARGS %' ,TG_NARGS;
        RAISE NOTICE 'TG_NAME %' ,TG_NAME;
        RETURN NEW;

    END;
$$LANGUAGE plpgsql;


__DISALLOW DELETE__
RETURN NULL ON fn_trigger();

TRUNCATE tb_name;
SAME AS DELETE FROM tb_name;

__Conditional Trigger__
CREATE TRIGGER tg_name
BEFORE UPDATE OR DELETE OR INSERT OR TRUNCATE
ON tb_name
FOR EACH STATEMENT
WHERE
(
condition 1 and 
condition 2
)
EXECUTE FUNCTION fn_name();

__LIMIT UPDATE ON PKEY__
BEFORE UPDATE ON id;


__EVENT Triggers__
ddl_command_start --Before crud;
ddl_command_end   --After crud;
table_rewrite     --Before alter table;
sql_drop          --After Drop DB;

TG_TAG --The action being performed.
TG_EVENT -- The event done ddl start, stop,rewrite.


CREATE OR REPLACE FUNCTION fn_evn_audit() RETURNS EVENT_TRIGGER 
SECURITY DEFINER    --Execute as sudo
AS
$$
INSERT INTO(
ddl_event,    --text
ddl_function, --text
ddl_time  --timestamp
)
VALUE
(
TG_EVENT,
TG_TAG,
now()

)
$$ LANGUAGE PLPGSQL;


CREATE EVENT TRIGGER
ON ddl_command_start
WHEN 
TAG IN ('CREATE TABLE')
Execute function fn_evn_audit();



__CURSOR__
DECLARE cursor_name refcursor;

DO
$$
DECLARE
    out_text text default '';
    rec record;
  cur_all_emp CURSOR
  FOR
  SELECT
      *
  from
  employees;
    BEGIN
    open  cur_all_emp;
    LOOP
        FETCH cur_all_emp into rec;
        EXIT WHEN NOT FOUND;
        out_text = out_text || ',' || rec.first_name;
    end loop;
    RAISE NOTICE 'All Employees First Name: %', out_text;
    END;
$$ LANGUAGE plpgsql;


__CROSS TABS__

CREATE EXTENSION IF NOT EXISTS tablefunc


SELECT * FROM crosstab
(
    '
 SELECT location, year, sum(raindays)::int from rainfalls GROUP BY location,year ORDER BY location,year desc;
    '
 )AS ct
(
"location" text,
   "2012" int,    --Uniques
   "2013" int,
   "2014"  int,
   "2015" int,
   "2016" int,
   "2017" int


 );
 
 
__TRANSACTION__
BEGIN
code
COMMIT;
ROLLBACK:

SAVEPOINT svp1;

ROLLBACK TO svp1;



  

  
  
  
